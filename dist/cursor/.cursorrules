# leafhill.io Development Rules (v1.3.0)

Universal AI coding skill for establishing and enforcing language-agnostic development standards. Use when defining code style rules, naming conventions, or documentation standards; scaffolding new project directory structures and boilerplate files; or documenting team workflow conventions such as branching strategies, commit message formats, and pull request processes. Do not use for framework-specific architecture patterns (React, Angular, Django, Rails), automated CI/CD pipeline authoring, cloud infrastructure provisioning (Terraform, Pulumi, CDK), or security vulnerability testing.

## Prioritization

| Priority | Layer                          | Default | Description                                    |
|----------|--------------------------------|---------|------------------------------------------------|
| 1        | **Leafhill Dev Specifications** | on      | Explicit rules unique to this skill. Always win on conflicts. |
| 2.1      | **roam-code**                  | on      | Codebase navigation and context gathering.               |
| 2.2      | **persistent-memory**          | on      | Cross-session task tracking and project memory.          |
| 2.3      | **superpowers skill**          | on      | Workflow orchestration (brainstorming, debugging, TDD, code review, etc.). |
| 3        | **Common Specifications**      | on      | General coding standards and best practices defined in this file. |

roam-code, persistent-memory, and superpowers are enabled by default and expected to be installed. If not installed, remind the user:
- "roam-code is required by leafhill-dev but is not currently installed. Please install it for codebase navigation."
- "persistent-memory (leafhill-persistent-memory MCP server) is required by leafhill-dev but is not currently available. Please install it for cross-session task tracking and project memory."
- "superpowers skill is required by leafhill-dev but is not currently installed. Please install it for workflow orchestration."

All three can be disabled per-project via `leafhill.config.md` (`roam_code: off` / `persistent_memory: off` / `superpowers: off`). When disabled, skip the layer and do not remind.

---

# LEAFHILL DEV SPECIFICATIONS (Priority 1)

## Configuration
Check the project root for `leafhill.config.md`. If found, apply its settings (they override Common Specification defaults). If not found, use defaults.

## roam-code Initialization
When `roam_code` is enabled (default: on), check at the start of every session:
1. Run `roam --version`. If not found, remind user to install roam-code. Stop here.
2. If CLAUDE.md exists, run `roam describe` and check if its first non-empty line already appears in CLAUDE.md. If found, skip to step 5. If CLAUDE.md does not exist, proceed.
3. Ask user: "roam-code is installed. Would you like me to run `roam describe` and add the codebase description to your CLAUDE.md?"
4. If confirmed: run `roam describe`. Prepend output to existing CLAUDE.md (blank line separator), or create CLAUDE.md with the output if it doesn't exist. If user declines, skip to step 5.
5. If `leafhill.config.md` has a `## Project Status` section, update `codebase_description:` with the roam describe output (blockquote format, each line prefixed with `> `). Reuse output from step 4 if available. Skip if already matching.
6. If `leafhill.config.md` has a `## Project Status` section, run `roam health`, extract the score, and set `health_check:` to `SCORE -- DATOR -- vX.Y.Z` (date-only DATOR variant). If `roam health` fails, skip silently.

## Version Tracking
When the system version is updated, always update `application_version.txt` with the new version number.

## Release Audit Protocol
On every minor or major version bump, perform a mandatory release audit before distribution. Act as Senior Quality Officer and CISO. Review all distribution copies against: OWASP Top 10+ adapted for AI skill instructions (injection risks, access control, data exposure, security misconfiguration, dependencies, logging, prompt injection resistance, supply chain risks, excessive permissions, insecure defaults), ISO 27001 checks (information classification, access control policy, change management, incident response, asset management), and quality review (consistency across dist copies, completeness, clarity, version alignment). Output numbered findings with severity (Critical/High/Medium/Low/Info). Critical and High must be resolved before release. Write all findings to the audit output files (see below). After writing audit output files, also update the `## Project Status` section in `leafhill.config.md` (if the file and section exist) — see Audit Output Files below.

## DATOR Variable
**DATOR** is the standard datetime format for all timestamps. Format: `%Y%m%d%H%M%S` (e.g., `20260224140244`). Date-only variant: `%Y%m%d` (e.g., `20260224`) — used only for audit headers. Use DATOR for all file names, session IDs, and timestamps. Do not use other date formats.

## Audit Output Files
Write audit findings to two files in the project root: `INFORMATIONSECURITY_AUDIT.md` (OWASP + ISO 27001 findings) and `QUALITY_AUDIT.md` (Quality Review findings). Each entry has a header (`## Audit — vX.Y.Z — DATOR` using date-only variant), numbered findings with severity, a summary table, and a verdict (PASS/FAIL). New audits are prepended above existing content — old entries are never removed. If the file exists, read and prepend; if not, create it. After writing to audit output files, also update `leafhill.config.md` if it exists and contains a `## Project Status` section: set `quality_audit:` to `VERDICT vX.Y.Z -- DATOR` and `infosec_audit:` to `VERDICT vX.Y.Z -- DATOR` (date-only DATOR variant). Skip silently if the config or section does not exist.

## File and Directory Creation
- Never use glob patterns or brace expansion when creating files or directories
- Use direct, explicit file and folder names for all creation operations

## Project Boundaries
- Stay in the project folder — no access outside project root without permission
- Do not commit, push, or install packages without explicit user request

## Config System
Projects can use `leafhill.config.md` to override defaults:
- type: personal | open-source | company (default: personal)
- vcs: git | none (default: git)
- branching: simple | trunk-based | gitflow (default: simple)
- commit_style: conventional | free-form (default: conventional)
- primary: python | javascript | typescript | go | rust | other (default: auto-detect)
- test_framework: any string (default: auto-detect)
- roam_code: on | off (default: on)
- superpowers: on | off (default: on)
- persistent_memory: on | off (default: on)

Auto-populated keys (Project Status — do not edit manually):
- codebase_description: blockquote from roam describe (session startup)
- health_check: SCORE -- DATOR -- vX.Y.Z (session startup)
- quality_audit: VERDICT vX.Y.Z -- DATOR (release audit)
- infosec_audit: VERDICT vX.Y.Z -- DATOR (release audit)

## Session Exit Protocol
Before ending a session, always export a session summary to a timestamped file (`DATOR-session-description.txt`) in the project root. Include: what was worked on, current state, decisions made, next steps. Never exit without saving. When `persistent_memory` is enabled, also log the summary to persistent memory and update task statuses. See Persistent Memory below.

## Persistent Memory
When `persistent_memory` is enabled (default: on), use the leafhill-persistent-memory MCP server for task tracking and cross-session continuity.

At session start when enabled:
1. Test MCP availability by calling `list_tasks` with the project name. If unavailable, inform the user and continue without it.
2. If available, load open tasks (pending/in_progress/blocked) and search relevant memories for the project.

Task lifecycle:
- Create tasks for multi-interaction or multi-session work, not trivial one-off requests
- Always set `project` to the project name from config or directory name
- Update status as work progresses: pending -> in_progress -> completed/blocked
- Use task_type: claude (AI work), human (user action needed), hybrid (both)
- Use subtasks for large work (2-5 per parent), dependencies only when genuinely blocking

Memory and context:
- Store decisions, patterns, facts, insights as memories. Tag with project name.
- Never store secrets, credentials, or sensitive data in memories
- Link related tasks, memories, and conversations with meaningful relation labels

Session integration:
- On session exit, also log the summary via `log_conversation` (session_id: project-name/DATOR, entry_type: summary)
- Update all task statuses before exiting
- The timestamped file export remains mandatory — persistent memory is an addition, not a replacement

---

# COMMON SPECIFICATIONS (Priority 3)

## Coding Standards

### Naming
- Files: kebab-case (e.g., `user-profile.ts`)
- Variables/Functions: camelCase (JS/TS), snake_case (Python/Go/Rust)
- Classes: PascalCase
- Constants/Env vars: UPPER_SNAKE_CASE
- CSS classes: kebab-case

### Code Organization
- One concern per file
- Group by feature, not by type
- Keep files under ~300 lines
- Imports: standard library, then third-party, then local (separated by blank lines)

### Documentation
- Add comments only when the _why_ is not obvious from the code
- Add docstrings to public API functions, classes, and modules
- Remove commented-out code — use version control
- Include a README.md in every project

### Error Handling
- Validate at system boundaries, trust internal code
- Fail early and clearly
- Use typed errors when available
- Log actionable information

## Project Structure

Standard layout: `src/`, `tests/`, `docs/`, `scripts/`, `config/`
Required files: `README.md`, `.gitignore` (when using git)

## Development Workflow

### Version Control (default: git)
- Commit early, commit often — one logical change per commit
- Conventional commits: `type(scope): description`
- Types: feat, fix, docs, style, refactor, test, chore, build, ci, perf

### Branching (default: simple)
- `main` branch + short-lived feature branches

### PRs
- Keep under 400 lines changed
- Descriptive titles

### Testing
- Test business logic and behavior, not implementation
- Descriptive test names
- Keep tests fast
- Mirror source structure in test files

## AI Behavior (Common)

### General
- Read existing code before modifying it
- Stay in scope — do not refactor unrelated code
- Make minimal changes — do not add unrequested features or abstractions
- Respect existing codebase patterns
- Confirm with the user before destructive actions

### Communication
- Keep responses concise and direct
- Prefer code examples over lengthy explanations
- Surface trade-offs when multiple approaches exist
- State uncertainty explicitly rather than guessing

## Language Notes

**JS/TS:** Prefer `const` over `let`, prefer strict equality (`===`), prefer async/await, do not mix JS and TS
**Python:** Follow PEP 8, add type hints, prefer f-strings, use virtual environments
**Go:** Run `gofmt`/`goimports`, handle errors explicitly
**Rust:** Enable `clippy`, prefer `Result` over `unwrap()`, run `cargo fmt`
